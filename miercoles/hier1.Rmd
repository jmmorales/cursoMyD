---
output:
  knitrBootstrap::bootstrap_document:
    title: "intro"
    theme: cosmo
    highlight: Solarized - Light
    theme.chooser: TRUE
    highlight.chooser: TRUE
---

```{r, echo=FALSE}
library(knitr)
options(figure_counter = FALSE)
opts_knit$set(eval.after='fig.cap')
knitr::opts_chunk$set(tidy=TRUE, echo=TRUE, warning=FALSE, message=FALSE, dev='svg')
```

# Análisis jerárquico de mortalidad

## ejemplo con datos simulados

 objetivos: 
 1. simular datos con estructura jerárquica
 2. realizar análisis de "complete pooling" y "no-pooling"
 3. comparar los análisis anteriores con un modelo jerárquico usando JAGS

suponiendo que estudiamos $10$ sub-poblaciones de una región y que seguimos la supervivencia de un número variable de individuos en cada sub-población. Vamos a simular datos con estructura jerárquica. La idea es que todas las sub-poblaciones son parte de una misma "metapoblación", son de la misma especie, etc. Esto hace que esperemos que los parámetros de supervivencia sean parecidos entre las sub-poblaciones, pero que tengan cierto grado de diferencia. Para modelar la variabilidad entre sub-poblaciones podemos usar una distribución Beta, por ejemplo con parámetros $a_s = 2$ y $b_s = 10$. Si repasamos el [Bestiario](https://sites.google.com/site/pajarom/me/Bestiario_sp.pdf?) vemos que esta combinación de parámetros resulta en un valor esperado de $a_s/(a_s+b_s)$ = `r 2/(2+10)` y una varianza de $(a_s * b_s)/((a_s+b_s)^2 * (a_s+b_s+1))$ = `r (2 * 10)/((2 + 10)^2 * (2 + 10 +1))`. Entonces, cada sub-población tendrá su propia tasa de supervivencia. Para simular los datos hacemos:

```{r}
set.seed <- 1234

n <- 10 # subgrupos
m <- c(30, 28, 20, 30, 30, 26, 29, 5, 3, 27) # individuos por grupo

a_s <- 2
b_s <- 10
 
theta <- rbeta(n, a_s, b_s) # generamos n tasas de mortalidad    
y <- rbinom(n, size=m, prob=theta)    # simulamos número de muertes por grupo
plot(table(y), xlab="Número de Muertes")

```

Podemos modelar estos datos asumiendo que:
1. todas las sub-poblaciones tienen igual mortalidad (complete pooling)
2. cada sub-población tiene una tasa de mortalidad independiente de las otras (no pooling)
3. cada sub-población es diferente pero parecida a las otras (partial pooling)

Vamos por partes:
(1) complete pooling

En este caso, como el modelo de datos (cuántos individuos mueren) es una Binomial, podemos usar una Beta como previa conjuda. Si queremos usar previas no-informativas para la tasa de mortalidad hacemos:
```{r}
alpha <- 1;
beta <- 1;

# graficamos la posterior
x <- seq(from = 0, to = 1, by = 0.01)  # variable para el gráfico
pos_theta1 <- dbeta(x, alpha + sum(y) , beta + sum( (m-y)))
plot(x,pos_theta1, type = "l", lty=5, lwd=2, ylab="Densidad", xlab="Tasa de Mortalidad")
```

Preguntas: 
- ¿Cuál es el valor esperado de la posterior de la tasa de mortalidad asumiendo "complete pooling"?
- ¿Cómo compara esa posterior con la media de supervivencia?

Ahora veamos qué estimaciones obtenemos si asumimos "no pooling", de nuevo usando previas no informativas:

```{r}
pos_theta2 <- matrix(0,n,length(x))
plot(x,pos_theta1, type = "l", lty=5, lwd=2, ylab="Densidad", xlab="Tasa de Mortalidad")
for (i in 1:10){
 pos_theta2[i,] <- dbeta(x, alpha + y[i] , beta + m[i] - y[i])
 lines(x,pos_theta2[i,], lwd=2)
}
````

Preguntas:
- ¿Qué se puede decir de las distintas posteriores?
- ¿Cómo estimaríamos una tasa de mortalidad promedio para la meta-población a partir de estas posteriores?

Finalmente, podemos hacer un análisis jerárquico (partial pooling), reconociendo explícitamente que cada sub-población es potencialmente distinta de las otras, pero sin embargo, todas son parte de la misma meta-población y por ende las observaciones en las sub-poblaciones no son del todo independientes.

Para este análisis vamos a usar JAGS. Primero tenemos que escribir el modelo en lenguaje BUGS y guardarlo en un archivo de texto que llamaremos "hier.bug":

```{r}
cat(file="hier.bug",
    "
    model
{
  for( i in 1 : n ) {
		y[i] ~ dbin(theta[i], m[i])	
		theta[i] ~ dbeta(a,b)
		}
		a ~ dnorm(0,0.001)T(0,)
		b ~ dnorm(0,0.001)T(0,)
    mean_pobl <- a/(a+b)
}
    ")
```
Luego definimos la lista de datos que vamos a pasarle a JAGS, una función para los valores iniciales de las cadenas Markovianas, y la lista de parámetros que queremos guardar.

```{r}
data <- list("y","m","n")
inits <- function() list(a = runif(1,1,5),b = runif(1,5,20))
params <- c("a","b","theta", "mean_pobl")

```

Ahora sólo queda cargar los paquetes de R que sirven para comunicarse con JAGS, definir las iteraciones, número de cadenas a correr y cuántos valores descartar como burn-in.
```{r, tidy=TRUE}
library(jagsUI)
ni <- 5000
nc <- 3
nt <- 4
nb <- 2500

hier.sim <- jags(data,inits,params, model.file="hier.bug",
                       n.chains=nc,n.iter=ni, n.burnin=nb, n.thin=nt)
print(hier.sim)
```

```{r}
a.sim <- hier.sim$sims.list$a
b.sim <- hier.sim$sims.list$b
# media de la Beta 
mean(hier.sim$sims.list$mean_pobl)    # comparar con el valor usado para simular los datos 

#------------  Graficamos los resultados de los distintos análisis  ------------
alpha = 1;
beta = 1;
x = seq(from = 0, to = 1, by = 0.01)

op = par(mfrow=c(1,2), mar=c(4,4,1,1)+0.1)
 pos_theta1 = dbeta(x, alpha + sum(y) , beta + sum( (m-y)))
 plot(x,pos_theta1, type = "l", lty=5, lwd=2, ylab="Densidad", xlab="Tasa de Mortalidad", ylim=c(0,20))
 pos_theta2 = matrix(0,10,length(x))
 for (i in 1:10){ 
  pos_theta2[i,] = dbeta(x, alpha + y[i] , beta + m[i] - y[i])
  lines(x,pos_theta2[i,],lwd=2)
 }
 plot(x,dbeta(x,mean(hier.sim$sims.list$a),mean(hier.sim$sims.list$b)),lwd=2,col=2, xlab="Tasa de Mortalidad",ylab="Densidad",type="l", ylim=c(0,20))
 lines(x,pos_theta1, type = "l", lty=5, lwd=2)
 for (i in 1:10){
  lines(density(hier.sim$sims.list$theta[,i]),col="blue",lwd=1) 
 } 
 lines(density(hier.sim$sims.list$mean_pobl),lwd=2,col=2)  
par(op)  
```